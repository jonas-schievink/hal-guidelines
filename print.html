<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Embedded Rust HAL Guidelines</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="This is a set of recommendations on how to design and present Rust HALs for microcontrollers.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="about.html">About</a></li><li class="chapter-item expanded affix "><a href="checklist.html">Checklist</a></li><li class="chapter-item expanded "><a href="naming.html"><strong aria-hidden="true">1.</strong> Naming</a></li><li class="chapter-item expanded "><a href="interoperability.html"><strong aria-hidden="true">2.</strong> Interoperability</a></li><li class="chapter-item expanded "><a href="predictability.html"><strong aria-hidden="true">3.</strong> Predictability</a></li><li class="chapter-item expanded "><a href="gpio.html"><strong aria-hidden="true">4.</strong> GPIO</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Embedded Rust HAL Guidelines</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#unofficial-embedded-rust-hal-guidelines" id="unofficial-embedded-rust-hal-guidelines">(unofficial) Embedded Rust HAL Guidelines</a></h1>
<p>This is a set of guidelines for writing hardware abstraction layers (HALs) for
microcontrollers in Rust. These guidelines are intended to be used in addition
to the existing <a href="https://rust-lang.github.io/api-guidelines/">Rust API Guidelines</a> when writing HALs for microcontrollers.</p>
<h1><a class="header" href="#rust-api-guidelines-checklist" id="rust-api-guidelines-checklist">Rust API Guidelines Checklist</a></h1>
<ul>
<li><strong>Naming</strong> <em>(crate aligns with Rust naming conventions)</em>
<ul>
<li><input disabled="" type="checkbox"/>
The crate is named appropriately (<a href="naming.html#c-crate-name">C-CRATE-NAME</a>)</li>
</ul>
</li>
<li><strong>Interoperability</strong> <em>(crate interacts nicely with other library functionality)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Wrapper types provide a destructor method (<a href="interoperability.html#c-free">C-FREE</a>)</li>
<li><input disabled="" type="checkbox"/>
HALs reexport their register access crate (<a href="interoperability.html#c-reexport-pac">C-REEXPORT-PAC</a>)</li>
<li><input disabled="" type="checkbox"/>
Types implement the <code>embedded-hal</code> traits (<a href="interoperability.html#c-hal-traits">C-HAL-TRAITS</a>)</li>
</ul>
</li>
<li><strong>Predictability</strong> <em>(crate enables legible code that acts how it looks)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Constructors are used instead of extension traits (<a href="predictability.html#c-ctor">C-CTOR</a>)</li>
</ul>
</li>
<li><strong>GPIO Interfaces</strong> <em>(GPIO Interfaces follow a common pattern)</em>
<ul>
<li><input disabled="" type="checkbox"/>
Pin types are zero-sized by default (<a href="gpio.html#c-zst-pin">C-ZST-PIN</a>)</li>
<li><input disabled="" type="checkbox"/>
Pin types provide methods to erase pin and port (<a href="gpio.html#c-erased-pin">C-ERASED-PIN</a>)</li>
<li><input disabled="" type="checkbox"/>
Pin state should be encoded as type parameters (<a href="gpio.html#c-pin-state">C-PIN-STATE</a>)</li>
</ul>
</li>
</ul>
<h1><a class="header" href="#naming" id="naming">Naming</a></h1>
<p><a id="c-crate-name"></a></p>
<h2><a class="header" href="#the-crate-is-named-appropriately-c-crate-name" id="the-crate-is-named-appropriately-c-crate-name">The crate is named appropriately (C-CRATE-NAME)</a></h2>
<p>HAL crates should be named after the chip or family of chips they aim to
support. Their name should end with <code>-hal</code> to distinguish them from register
access crates. The name should not contain underscores (use dashes instead).</p>
<h1><a class="header" href="#interoperability" id="interoperability">Interoperability</a></h1>
<p><a id="c-free"></a></p>
<h2><a class="header" href="#wrapper-types-provide-a-destructor-method-c-free" id="wrapper-types-provide-a-destructor-method-c-free">Wrapper types provide a destructor method (C-FREE)</a></h2>
<p>Any non-<code>Copy</code> wrapper type provided by the HAL should provide a <code>free</code> method
that consumes the wrapper and returns back the raw peripheral (and possibly
other objects) it was created from.</p>
<p>The method should shut down and reset the peripheral if necessary. Calling <code>new</code>
with the raw peripheral returned by <code>free</code> should not fail due to an unexpected
state of the peripheral.</p>
<p>If the HAL type requires other non-<code>Copy</code> objects to be constructed (for example
I/O pins), any such object should be released and returned by <code>free</code> as well.
<code>free</code> should return a tuple in that case.</p>
<p>For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct TIMER0;
</span>pub struct Timer(TIMER0);

impl Timer {
    pub fn new(periph: TIMER0) -&gt; Self {
        Self(periph)
    }

    pub fn free(self) -&gt; TIMER0 {
        self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><a id="c-reexport-pac"></a></p>
<h2><a class="header" href="#hals-reexport-their-register-access-crate-c-reexport-pac" id="hals-reexport-their-register-access-crate-c-reexport-pac">HALs reexport their register access crate (C-REEXPORT-PAC)</a></h2>
<p>HALs can be written on top of <a href="https://github.com/rust-embedded/svd2rust">svd2rust</a>-generated PACs, or on top of other
crates that provide raw register access. HALs should always reexport the
register access crate they are based on in their crate root.</p>
<p>A PAC should be reexported under the name <code>pac</code>, regardless of the actual name
of the crate, as the name of the HAL should already make it clear what PAC is
being accessed.</p>
<p><a id="c-hal-traits"></a></p>
<h2><a class="header" href="#types-implement-the-embedded-hal-traits-c-hal-traits" id="types-implement-the-embedded-hal-traits-c-hal-traits">Types implement the <code>embedded-hal</code> traits (C-HAL-TRAITS)</a></h2>
<p>Types provided by the HAL should implement all applicable traits provided by the
<a href="https://github.com/rust-embedded/embedded-hal"><code>embedded-hal</code></a> crate.</p>
<p>Multiple traits may be implemented for the same type.</p>
<h1><a class="header" href="#predictability" id="predictability">Predictability</a></h1>
<p><a id="c-ctor"></a></p>
<h2><a class="header" href="#constructors-are-used-instead-of-extension-traits-c-ctor" id="constructors-are-used-instead-of-extension-traits-c-ctor">Constructors are used instead of extension traits (C-CTOR)</a></h2>
<p>All peripherals to which the HAL adds functionality should be wrapped in a new
type, even if no additional fields are required for that functionality.</p>
<p>Extension traits implemented for the raw peripheral should be avoided.</p>
<p><a id="c-inline"></a></p>
<h2><a class="header" href="#methods-are-decorated-with-inline-where-appropriate-c-inline" id="methods-are-decorated-with-inline-where-appropriate-c-inline">Methods are decorated with <code>#[inline]</code> where appropriate (C-INLINE)</a></h2>
<p>The Rust compiler does not by default perform full inlining across crate
boundaries. As embedded applications are sensitive to unexpected code size
increases, <code>#[inline]</code> should be used to guide the compiler as follows:</p>
<ul>
<li>All &quot;small&quot; functions should be marked <code>#[inline]</code>. What qualifies as &quot;small&quot;
is subjective, but generally all functions that are expected to compile down
to single-digit instruction sequences qualify as small.</li>
<li>Functions that are very likely to take constant values as parameters should be
marked as <code>#[inline]</code>. This enables the compiler to compute even complicated
initialization logic at compile time, provided the function inputs are known.</li>
</ul>
<h1><a class="header" href="#guidelines-for-gpio-interfaces" id="guidelines-for-gpio-interfaces">Guidelines for GPIO Interfaces</a></h1>
<p><a id="c-zst-pin"></a></p>
<h2><a class="header" href="#pin-types-are-zero-sized-by-default-c-zst-pin" id="pin-types-are-zero-sized-by-default-c-zst-pin">Pin types are zero-sized by default (C-ZST-PIN)</a></h2>
<p>GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types for
each pin on every interface or port, resulting in a zero-cost GPIO abstraction
when all pin assignments are statically known.</p>
<p>Each GPIO Interface or Port should implement a <code>split</code> method returning a
struct with every pin.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct PA0;
pub struct PA1;
// ...

pub struct PortA;

impl PortA {
    pub fn split(self) -&gt; PortAPins {
        PortAPins {
            pa0: PA0,
            pa1: PA1,
            // ...
        }
    }
}

pub struct PortAPins {
    pub pa0: PA0,
    pub pa1: PA1,
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><a id="c-erased-pin"></a></p>
<h2><a class="header" href="#pin-types-provide-methods-to-erase-pin-and-port-c-erased-pin" id="pin-types-provide-methods-to-erase-pin-and-port-c-erased-pin">Pin types provide methods to erase pin and port (C-ERASED-PIN)</a></h2>
<p>Pins should provide type erasure methods that move their properties from
compile time to runtime, and allow more flexibility in applications.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Port A, pin 0.
pub struct PA0;

impl PA0 {
    pub fn erase_pin(self) -&gt; PA {
        PA { pin: 0 }
    }
}

/// A pin on port A.
pub struct PA {
    /// The pin number.
    pin: u8,
}

impl PA {
    pub fn erase_port(self) -&gt; Pin {
        Pin {
            port: Port::A,
            pin: self.pin,
        }
    }
}

pub struct Pin {
    port: Port,
    pin: u8,
    // (these fields can be packed to reduce the memory footprint)
}

enum Port {
    A,
    B,
    C,
    D,
}
<span class="boring">}
</span></code></pre></pre>
<p><a id="c-pin-state"></a></p>
<h2><a class="header" href="#pin-state-should-be-encoded-as-type-parameters-c-pin-state" id="pin-state-should-be-encoded-as-type-parameters-c-pin-state">Pin state should be encoded as type parameters (C-PIN-STATE)</a></h2>
<p>Pins may be configured as input or output with different characteristics
depending on the chip or family. This state should be encoded in the type system
to prevent use of pins in incorrect states.</p>
<p>Additional, chip-specific state (eg. drive strength) may also be encoded in this
way, using additional type parameters.</p>
<p>Methods for changing the pin state should be provided as <code>into_input</code> and
<code>into_output</code> methods.</p>
<p>An <code>erase_state</code> method for erasing the type information (replacing it with an
<code>Unknown</code> type) should be provided for making pins in different states
interoperable.</p>
<p>Additionally, <code>with_{input,output}_state</code> methods should be provided that
temporarily reconfigure a pin in a different state without moving it.</p>
<p>The following methods should be provided for every pin type (that is, both
erased and non-erased pin types should provide the same API):</p>
<ul>
<li><code>pub fn into_input&lt;N: InputState&gt;(self, input: N) -&gt; Pin&lt;N&gt;</code></li>
<li><code>pub fn into_output&lt;N: OutputState&gt;(self, output: N) -&gt; Pin&lt;N&gt;</code></li>
<li><code>pub fn erase_state(self) -&gt; Pin&lt;Unknown&gt;</code></li>
<li>
<pre><code>pub fn with_input_state&lt;N: InputState, R&gt;(
    &amp;mut self,
    input: N,
    f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
) -&gt; R
</code></pre>
</li>
<li>
<pre><code>pub fn with_output_state&lt;N: OutputState, R&gt;(
    &amp;mut self,
    output: N,
    f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
) -&gt; R
</code></pre>
</li>
</ul>
<p>Pin state should be bounded by sealed traits. Users of the HAL should have no
need to add their own state. The traits can provide HAL-specific methods
required to implement the pin state API.</p>
<p>Example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use core::mem::PhantomData;
</span>mod sealed {
    // ...
}

pub trait PinState: sealed::Sealed {}
pub trait OutputState: sealed::Sealed {}
pub trait InputState: sealed::Sealed {
    // ...
}

pub struct Unknown;

impl PinState for Unknown {}

pub struct Output&lt;S: OutputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: OutputState&gt; PinState for Output&lt;S&gt; {}

pub struct PushPull;
pub struct OpenDrain;

impl OutputState for PushPull {}
impl OutputState for OpenDrain {}

pub struct Input&lt;S: InputState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: InputState&gt; PinState for Input&lt;S&gt; {}

pub struct Floating;
pub struct PullUp;
pub struct PullDown;

impl InputState for Floating {}
impl InputState for PullUp {}
impl InputState for PullDown {}

pub struct PA1&lt;S: PinState&gt; {
    _p: PhantomData&lt;S&gt;,
}

impl&lt;S: PinState&gt; PA1&lt;S&gt; {
    pub fn into_input&lt;N: InputState&gt;(self, input: N) -&gt; PA1&lt;N&gt; {
        todo!()
    }

    pub fn into_output&lt;N: OutputState&gt;(self, output: N) -&gt; PA1&lt;N&gt; {
        todo!()
    }

    pub fn with_input_state&lt;N: InputState, R&gt;(
        &amp;mut self,
        input: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }

    pub fn with_output_state&lt;N: OutputState, R&gt;(
        &amp;mut self,
        output: N,
        f: impl FnOnce(&amp;mut PA1&lt;N&gt;) -&gt; R,
    ) -&gt; R {
        todo!()
    }

    pub fn erase_state(self) -&gt; PA1&lt;Unknown&gt; {
        todo!()
    }
}

// Same for `PA` and `Pin`, and other pin types.
<span class="boring">}
</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
